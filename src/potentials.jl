#!/usr/bin/julia
#
# Definitions of useful potential functions for use in simulations.
#
using UnitfulAtomic;
export gs_polarisation, radial_gaussian, radial_gaussian_harmonic_freq,
       tweezer_potential_depth, simple_harmonic, translate_trajectory, merge_radial_gaussian_harmonic_freq;

"""
    gs_polarisation(atom::String, λ::Number)

Find the frequency dependent ground state polarisability for Rubidium and
Caesium at the given wavelength.
"""
function gs_polarisation(atom::String, λ::Number)
  # Apply the relevant data.
  # Data from M. S. Safronova et al., Phys. Rev. A 73, 022505 (2006).
  # https://doi-org.ezphost.dur.ac.uk/10.1103/PhysRevA.73.022505
  if atom == "Cs" || atom == "cs"
    dip12 = 4.4890;
    dip32 = 6.3238;
    δE12 = 0.050932;
    δE32 = 0.053456;
    A = 17.35;
  elseif atom == "Rb" || atom == "rb"
    dip12 = 4.231;
    dip32 = 5.977;
    δE12 = 0.057314;
    δE32 = 0.058396;
    A = 10.54;
  else throw(ArgumentError("only data for Rb and Cs has been implemented")); end

  # Calculate frequency in atomic units.
  ω = ustrip(auconvert(2π*Unitful.c0/λ));

  # Return the ground state dynamic polarisability.
  α = 1/3 * ((δE12 * dip12^2)/(δE12^2 - ω^2)
             + (δE32 * dip32^2)/(δE32^2 - ω^2))
      + A;

  # Apply the atomic units.
  return α * unit(1Unitful.u"a0_au^3");
end

"""
    radial_gaussian(ω₀::Number, U₀::Number, r::AbstractVector{T}) where T<:Number

Returns the numerical values for the radial slice of a Gaussian function with
the parameters given defined over the values contained in `r`.
"""
function radial_gaussian(ω₀::Number, U₀::Number, r::AbstractVector{T}) where T<:Number
  return U₀ * (1 .- exp.(-2r.^2 / ω₀^2));
end

"""
    radial_gaussian_harmonic_freq(ω₀::Number, U₀::Number, m::Number)

Calculate the radial harmonic frequency for the Gaussian potential with the
given parameters
"""
function radial_gaussian_harmonic_freq(ω₀::Number, U₀::Number, m::Number)
  (4U₀/(m * ω₀^2))^(1/2)
end

"""
    tweezer_potential_depth(P::Number, α::Number, ω₀::Number)

Calculate the trap depth, U₀, for an optical tweezer generated by a Gaussian
laser beam with power `P`, frequency-dependent atomic ground state
polarisability of `α` (in a₀³) and beam waist `ω₀`.

Uses the SI unit conversion of `α(C m²/V) = 4π ϵ₀ a₀³ α(a₀³)` with the potential
depth given by `U₀ = (P α)/(π c ϵ₀ ω₀²)`.
"""
function tweezer_potential_depth(P::Number, α::Number, ω₀::Number)
  return (4*ustrip(α)*Unitful.uconvert(Unitful.u"m", 1Unitful.u"a0_au")^3*P)/
         (Unitful.c0 * ω₀^2);
end

"""
    simple_harmonic(m::Number, ω::Number, x::AbstractVector{T}) where T<:Number

Returns the numerical values for the simple harmonic function with the
parameters given defined over the values contained in `x`.
"""
function simple_harmonic(m::Number, ω::Number, x::AbstractVector{T}) where T<:Number
  return 0.5 * m * ω^2 * x.^2;
end

"""
    translate_trajectory(r, b, Ua, ω₀a, Ub, ω₀b)

Translate between the intended trajectory for the minimum of the radial
component of two merging Gaussian potentials and the location of the potential.
"""
function translate_trajectory(r, b, Ua, ω₀a, Ub, ω₀b)
  wa = ω₀a;
  wb = ω₀b;

  expo4b2r2 = exp(4*(b^2 + r^2)/wb^2);
  expo2b2r2 = exp(2*(b^2 + r^2)/wb^2);

  longsqrt = sqrt(3)*sqrt(complex(wa^6*(-2*Ua^2*wb^4*expo4b2r2 + 27*Ub^2*wa^2*(b^2 - 2*b*r + r^2)*exp(8*b*r/wb^2))/ (expo4b2r2*Ua^2*wb^4)));

  postsqrt = -9*Ub*wa^4*(b - r)*exp(-2*(b^2 - 2*b*r + r^2)/wb^2)/(Ua*wb^2);

  # We want the first imaginary root of the general solution case.
  a = 3^(2/3)*(2^(2/3)*wa^2/3 + 3^(1/3)*(1 + sqrt(3)*im)* (12*r + 6^(1/3)*(1 + sqrt(3)*im)*(longsqrt + postsqrt)^(1/3))*(longsqrt + postsqrt)^(1/3)/36)/
            (((Ua*longsqrt*wb^2*expo2b2r2 + 9*Ub*wa^4*(-b + r)*exp(4*b*r/wb^2))/(expo2b2r2*Ua*wb^2))^(1/3)*(1 + sqrt(3)*im));

  # This is the full (unsimplified) expression.
  #a = 3^(2/3)*(2^(2/3)*wa^2/3 + 3^(1/3)*(1 + sqrt(3)*im)*(12*r + 6^(1/3)*(1 + sqrt(3)*im)*(-54*r^3 + 9*r*wa^2 + 9*r*(6*r^2 - wa^2) + sqrt(3)*sqrt(complex((-2*Ua^2*wa^6*wb^4*exp(4*b^2/wb^2 + 4*r^2/wb^2) + 27*(-2*Ua*r^3*wb^2*exp(2*b^2/wb^2 + 2*r^2/wb^2) + Ua*r*wa^2*wb^2*exp(2*b^2/wb^2 + 2*r^2/wb^2) + Ua*r*wb^2*(2*r^2 - wa^2)*exp(2*b^2/wb^2 + 2*r^2/wb^2) - Ub*b*wa^4*exp(4*b*r/wb^2) + Ub*r*wa^4*exp(4*b*r/wb^2))^2)*exp(-4*b^2/wb^2 - 4*r^2/wb^2)/(Ua^2*wb^4))) - 9*Ub*b*wa^4*exp(-2*b^2/wb^2 + 4*b*r/wb^2 - 2*r^2/wb^2)/(Ua*wb^2) + 9*Ub*r*wa^4*exp(-2*b^2/wb^2 + 4*b*r/wb^2 - 2*r^2/wb^2)/(Ua*wb^2))^(1/3))*(-54*r^3 + 9*r*wa^2 + 9*r*(6*r^2 - wa^2) + sqrt(3)*sqrt(complex((-2*Ua^2*wa^6*wb^4*exp(4*b^2/wb^2 + 4*r^2/wb^2) + 27*(-2*Ua*r^3*wb^2*exp(2*b^2/wb^2 + 2*r^2/wb^2) + Ua*r*wa^2*wb^2*exp(2*b^2/wb^2 + 2*r^2/wb^2) + Ua*r*wb^2*(2*r^2 - wa^2)*exp(2*b^2/wb^2 + 2*r^2/wb^2) - Ub*b*wa^4*exp(4*b*r/wb^2) + Ub*r*wa^4*exp(4*b*r/wb^2))^2)*exp(-4*b^2/wb^2 - 4*r^2/wb^2)/(Ua^2*wb^4))) - 9*Ub*b*wa^4*exp(-2*b^2/wb^2 + 4*b*r/wb^2 - 2*r^2/wb^2)/(Ua*wb^2) + 9*Ub*r*wa^4*exp(-2*b^2/wb^2 + 4*b*r/wb^2 - 2*r^2/wb^2)/(Ua*wb^2))^(1/3)/36)/(((-18*Ua*r^3*wb^2*exp(2*b^2/wb^2 + 2*r^2/wb^2) + 9*Ua*r*wa^2*wb^2*exp(2*b^2/wb^2 + 2*r^2/wb^2) + Ua*wb^2*(-36*r^3 + 9*r*(6*r^2 - wa^2) + sqrt(3)*sqrt(complex((-2*Ua^2*wa^6*wb^4*exp(4*b^2/wb^2 + 4*r^2/wb^2) + 27*(-2*Ua*r^3*wb^2*exp(2*b^2/wb^2 + 2*r^2/wb^2) + Ua*r*wa^2*wb^2*exp(2*b^2/wb^2 + 2*r^2/wb^2) + Ua*r*wb^2*(2*r^2 - wa^2)*exp(2*b^2/wb^2 + 2*r^2/wb^2) - Ub*b*wa^4*exp(4*b*r/wb^2) + Ub*r*wa^4*exp(4*b*r/wb^2))^2)*exp(-4*b^2/wb^2 - 4*r^2/wb^2)/(Ua^2*wb^4))))*exp(2*b^2/wb^2 + 2*r^2/wb^2) - 9*Ub*b*wa^4*exp(4*b*r/wb^2) + 9*Ub*r*wa^4*exp(4*b*r/wb^2))*exp(-2*b^2/wb^2 - 2*r^2/wb^2)/(Ua*wb^2))^(1/3)*(1 + sqrt(3)*im)); 
  a = Unitful.uconvert(unit(r), a)
  #println(a);
  # Has a small imaginary component which we'll ignore.
  return real(a);
end

"""
    merge_radial_gaussian_harmonic_freq(m, a, Ua, ω₀a, b, Ub, ω₀b)

Get the equivalent harmonic frequency of the trap in the radial direction given
the locations of the merging Gaussian potentials.
"""
function merge_radial_gaussian_harmonic_freq(m, a, Ua, ω₀a, b, Ub, ω₀b)
  wa = ω₀a;
  wb = ω₀b;

  expofac  = exp(2.0*(a^2 + b^2)/wb^2);
  ω = 2.0*sqrt(complex(-(Ua*wb^4*expofac + Ub*wa^2*exp(4.0*a*b/wb^2)*(-4.0a^2 + 8.0*a*b -4.0*b^2 + wb^2))/(m*expofac)))/(wa*wb^2);
  
  # Full un-simplified expression is:
  #ω = 2.0*sqrt(complex(-(Ua*wb^4*exp(2.0*(a^2 + b^2)/wb^2) - 4.0*Ub*a^2*wa^2*exp(4.0*a*b/wb^2) + 8.0*Ub*a*b*wa^2*exp(4.0*a*b/wb^2) - 4.0*Ub*b^2*wa^2*exp(4.0*a*b/wb^2) + Ub*wa^2*wb^2*exp(4.0*a*b/wb^2))*exp(-2.0*(a^2 + b^2)/wb^2)/m))/(wa*wb^2);

  return abs(ω);
end
