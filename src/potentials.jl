#!/usr/bin/julia
#
# Definitions of useful potential functions for use in simulations.
#
using UnitfulAtomic;
export gs_polarisation, radial_gaussian, radial_gaussian_harmonic_freq,
       tweezer_potential_depth, simple_harmonic, translate_trajectory;

"""
    gs_polarisation(atom::String, λ::Number)

Find the frequency dependent ground state polarisability for Rubidium and
Caesium at the given wavelength.
"""
function gs_polarisation(atom::String, λ::Number)
  # Apply the relevant data.
  # Data from M. S. Safronova et al., Phys. Rev. A 73, 022505 (2006).
  # https://doi-org.ezphost.dur.ac.uk/10.1103/PhysRevA.73.022505
  if atom == "Cs" || atom == "cs"
    dip12 = 4.4890;
    dip32 = 6.3238;
    δE12 = 0.050932;
    δE32 = 0.053456;
    A = 17.35;
  elseif atom == "Rb" || atom == "rb"
    dip12 = 4.231;
    dip32 = 5.977;
    δE12 = 0.057314;
    δE32 = 0.058396;
    A = 10.54;
  else throw(ArgumentError("only data for Rb and Cs has been implemented")); end

  # Calculate frequency in atomic units.
  ω = ustrip(auconvert(2π*Unitful.c0/λ));

  # Return the ground state dynamic polarisability.
  α = 1/3 * ((δE12 * dip12^2)/(δE12^2 - ω^2)
             + (δE32 * dip32^2)/(δE32^2 - ω^2))
      + A;

  # Apply the atomic units.
  return α * unit(1Unitful.u"a0_au^3");
end

"""
    radial_gaussian(ω₀::Number, U₀::Number, r::AbstractVector{T}) where T<:Number

Returns the numerical values for the radial slice of a Gaussian function with
the parameters given defined over the values contained in `r`.
"""
function radial_gaussian(ω₀::Number, U₀::Number, r::AbstractVector{T}) where T<:Number
  return U₀ * (1 .- exp.(-2r.^2 / ω₀^2));
end

"""
    radial_gaussian_harmonic_freq(ω₀::Number, U₀::Number, m::Number)

Calculate the radial harmonic frequency for the Gaussian potential with the
given parameters
"""
function radial_gaussian_harmonic_freq(ω₀::Number, U₀::Number, m::Number)
  (4U₀/(m * ω₀^2))^(1/2)
end

"""
    tweezer_potential_depth(P::Number, α::Number, ω₀::Number)

Calculate the trap depth, U₀, for an optical tweezer generated by a Gaussian
laser beam with power `P`, frequency-dependent atomic ground state
polarisability of `α` (in a₀³) and beam waist `ω₀`.

Uses the SI unit conversion of `α(C m²/V) = 4π ϵ₀ a₀³ α(a₀³)` with the potential
depth given by `U₀ = (P α)/(π c ϵ₀ ω₀²)`.
"""
function tweezer_potential_depth(P::Number, α::Number, ω₀::Number)
  return (4*ustrip(α)*Unitful.uconvert(Unitful.u"m", 1Unitful.u"a0_au")^3*P)/
         (Unitful.c0 * ω₀^2);
end

"""
    simple_harmonic(m::Number, ω::Number, x::AbstractVector{T}) where T<:Number

Returns the numerical values for the simple harmonic function with the
parameters given defined over the values contained in `x`.
"""
function simple_harmonic(m::Number, ω::Number, x::AbstractVector{T}) where T<:Number
  return 0.5 * m * ω^2 * x.^2;
end

#=
function translate_trajectory(r, b, Ua, ω₀a, Ub, ω₀b)
  units = unit(r);
  A = 2.0/ω₀a^2;
  B = 2.0/ω₀b^2;
  U = Ua;
  V = Ub;
  r = r;
  b = b;
  #=
  a = (-(2^(1/3)*A*U_1)/(-27*A^4*b^3*B^2*U_1^2*U_2 + 81*A^4*b^2*B^2*U_1^2*U_2*x -
                      81*A^4*b*B^2*U_1^2*U_2*x^2 - 27*A^4*b*B*U_1^2*U_2 + 27*A^4*
                    B^2*U_1^2*U_2*x^3 + 27*A^4*B*U_1^2*U_2*x + sqrt(108*A^9*
                    U_1^6 + (-27*A^4*b^3*B^2*U_1^2*U_2 + 81*A^4*b^2*B^2*U_1^2*
                           U_2*x - 81*A^4*b*B^2*U_1^2*U_2*x^2 - 27*A^4*b*B*U_1^2*
                         U_2 + 27*A^4*B^2*U_1^2*U_2*x^3 + 27*A^4*B*U_1^2*U_2*
                       x)^2))^(1/3) + (-27*A^4*b^3*B^2*U_1^2*U_2 + 81*A^4*b^2*
                                     B^2*U_1^2*U_2*x - 81*A^4*b*B^2*U_1^2*U_2*
                                   x^2 - 27*A^4*b*B*U_1^2*U_2 + 27*A^4*B^2*U_1^2*
                                 U_2*x^3 + 27*A^4*B*U_1^2*U_2*x + sqrt(108*A^9*
                                                                     U_1^6 +
                                                                   (-27*A^4*b^3*
                                                                  B^2*U_1^2*U_2
                                                                + 81*A^4*b^2*B^2*
                                                              U_1^2*U_2*x - 81*
                                                            A^4*b*B^2*U_1^2*U_2*
                                                          x^2 - 27*A^4*b*B*U_1^2*
                                                        U_2 + 27*A^4*B^2*U_1^2*
                                                      U_2*x^3 + 27*A^4*B*U_1^2*
                                                    U_2*x)^2))^(1/3)/(3*2^(1/3)*
                                                                    A^2*U_1) +
       x);
    =#

  #fac1 = 27A^4*b*B*U^2*V*exp(2B*(b - r)^2) - 27A^4*B*r*U^2*V*exp(2B*(b - r)^2);
  prefac =  27A^4*U^2*V*B*exp(2B*(b - r)^2);
  summand1 = prefac*(b - r);
  #fac2 = sqrt((27A^4*b*B*U^2*V*exp(2B*(b - r)^2) - 27A^4*B*r*U^2*V*exp(2B*(b - r)^2))^2 - 108A^9*U^6*exp(6B*(b - r)^2));
  sqrtcoef = summand1^2 - 108A^9*U^6*exp(6B*(b - r)^2);
  #if true sqrtcoef = abs(sqrtcoef); end
  sumq = summand1 + sqrt(complex(sqrtcoef));
  
  a = (2^(1/3)*A*U*exp(B*(b - r)^2))/sumq^(1/3) + (exp(-B*(b - r)^2)*sumq^(1/3))/(3*2^(1/3)*A^2*U) + r;


  #fac1 = 27A^4*b*B*U^2*V*exp(B*(b - r)^2) - 27A^4*B*r*U^2*V*exp(B*(b - r)^2);
  #fac2 = sqrt(108A^9*U^6 + (27A^4*B*r*U^2*V*exp(B*(b - r)^2) - 27A^4*b*B*U^2*V*exp(B*(b - r)^2))^2);

  #a = -(2^(1/3)*A*U)/fac^(1/3) + fac^(1/3)/(3*2^(1/3)*A^2*U) + r;
  println(Unitful.uconvert(unit(r),a));
  return Unitful.uconvert(unit(r), real(a));
end=#

"""
    translate_trajectory(r, b, Ua, ω₀a, Ub, ω₀b)

Translate between the intended trajectory for the minimum of the radial
component of two merging Gaussian potentials and the location of the potential.
"""
function translate_trajectory(r, b, Ua, ω₀a, Ub, ω₀b)
  w = ω₀a;
  y = ω₀b;
  U = Ua;
  V = Ub;

  s1 = 108U^2*V*w^4*y^4*exp((4*(b - r)^2)/y^2);
  f1 = s1*(b-r);
  sqcoef = f1^2 - 864U^6*w^6*y^12*exp((12*(b - r)^2)/y^2);
  sumterm = (f1 + sqrt(complex(sqcoef)))^(1/3);

  a1 = (exp(-(2*(b - r)^2)/y^2) * sumterm)/(6*2^(1/3)*U*y^2);

  a2 = (2^(1/3)*U*w^2*y^2*exp((2*(b - r)^2)/y^2)) / sumterm;

  #println(Unitful.uconvert(unit(r),a1+a2));

  a = r - (a1+a2);

  #a = (e^(-(2 (b - r)^2)/y^2) (108 b U^2 V w^4 y^4 e^((4 (b - r)^2)/y^2) - 108 r U^2 V w^4 y^4 e^((4 (b - r)^2)/y^2) + sqrt((108 b U^2 V w^4 y^4 e^((4 (b - r)^2)/y^2) - 108 r U^2 V w^4 y^4 e^((4 (b - r)^2)/y^2))^2 - 864 U^6 w^6 y^12 e^((12 (b - r)^2)/y^2)))^(1/3))/(6 2^(1/3) U y^2)
  #+ (2^(1/3) U w^2 y^2 e^((2 (b - r)^2)/y^2))/(108 b U^2 V w^4 y^4 e^((4 (b - r)^2)/y^2) - 108 r U^2 V w^4 y^4 e^((4 (b - r)^2)/y^2) + sqrt((108 b U^2 V w^4 y^4 e^((4 (b - r)^2)/y^2) - 108 r U^2 V w^4 y^4 e^((4 (b - r)^2)/y^2))^2 - 864 U^6 w^6 y^12 e^((12 (b - r)^2)/y^2)))^(1/3) + r and U y!=0 and w!=0

  a = Unitful.uconvert(unit(r), a)
  return real(a);
end
