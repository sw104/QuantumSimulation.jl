#!/usr/bin/julia
#
# Definitions of useful potential functions for use in simulations.
#
using UnitfulAtomic;
export gs_polarisation, radial_gaussian, radial_gaussian_harmonic_freq,
       tweezer_potential_depth, simple_harmonic, translate_trajectory, merge_radial_gaussian_harmonic_freq;

"""
    gs_polarisation(atom::String, λ::Number)

Find the frequency dependent ground state polarisability for Rubidium and
Caesium at the given wavelength.
"""
function gs_polarisation(atom::String, λ::Number)
  # Apply the relevant data.
  # Data from M. S. Safronova et al., Phys. Rev. A 73, 022505 (2006).
  # https://doi-org.ezphost.dur.ac.uk/10.1103/PhysRevA.73.022505
  if atom == "Cs" || atom == "cs"
    dip12 = 4.4890;
    dip32 = 6.3238;
    δE12 = 0.050932;
    δE32 = 0.053456;
    A = 17.35;
  elseif atom == "Rb" || atom == "rb"
    dip12 = 4.231;
    dip32 = 5.977;
    δE12 = 0.057314;
    δE32 = 0.058396;
    A = 10.54;
  else throw(ArgumentError("only data for Rb and Cs has been implemented")); end

  # Calculate frequency in atomic units.
  ω = ustrip(auconvert(2π*Unitful.c0/λ));

  # Return the ground state dynamic polarisability.
  α = 1/3 * ((δE12 * dip12^2)/(δE12^2 - ω^2)
             + (δE32 * dip32^2)/(δE32^2 - ω^2))
      + A;

  # Apply the atomic units.
  return α * unit(1Unitful.u"a0_au^3");
end

"""
    radial_gaussian(ω₀::Number, U₀::Number, r::AbstractVector{T}) where T<:Number

Returns the numerical values for the radial slice of a Gaussian function with
the parameters given defined over the values contained in `r`.
"""
function radial_gaussian(ω₀::Number, U₀::Number, r::AbstractVector{T}) where T<:Number
  return U₀ * (1 .- exp.(-2r.^2 / ω₀^2));
end

"""
    radial_gaussian_harmonic_freq(ω₀::Number, U₀::Number, m::Number)

Calculate the radial harmonic frequency for the Gaussian potential with the
given parameters
"""
function radial_gaussian_harmonic_freq(ω₀::Number, U₀::Number, m::Number)
  (4U₀/(m * ω₀^2))^(1/2)
end

"""
    tweezer_potential_depth(P::Number, α::Number, ω₀::Number)

Calculate the trap depth, U₀, for an optical tweezer generated by a Gaussian
laser beam with power `P`, frequency-dependent atomic ground state
polarisability of `α` (in a₀³) and beam waist `ω₀`.

Uses the SI unit conversion of `α(C m²/V) = 4π ϵ₀ a₀³ α(a₀³)` with the potential
depth given by `U₀ = (P α)/(π c ϵ₀ ω₀²)`.
"""
function tweezer_potential_depth(P::Number, α::Number, ω₀::Number)
  return (4*ustrip(α)*Unitful.uconvert(Unitful.u"m", 1Unitful.u"a0_au")^3*P)/
         (Unitful.c0 * ω₀^2);
end

"""
    simple_harmonic(m::Number, ω::Number, x::AbstractVector{T}) where T<:Number

Returns the numerical values for the simple harmonic function with the
parameters given defined over the values contained in `x`.
"""
function simple_harmonic(m::Number, ω::Number, x::AbstractVector{T}) where T<:Number
  return 0.5 * m * ω^2 * x.^2;
end

"""
    translate_trajectory(r, b, Ua, ω₀a, Ub, ω₀b)

Translate between the intended trajectory for the minimum of the radial
component of two merging Gaussian potentials and the location of the potential.
"""
function translate_trajectory(r, b, Ua, ω₀a, Ub, ω₀b)
  c = Ub/ω₀b^2 * (r-b) * exp(-2(r-b)^2/ω₀b^2);
  arg = -(2c * ω₀a/Ua)^2;
  #println("Argument: ", arg);
  if (abs(arg) > 1.0/exp(1))
    println("WARNING: outside of radius of convergence of series expansion!");
    println("Argument was ", arg);
  end
  #println(arg);

  lambert = 0.0;
  for i ∈ 1:10
    lambert += (-i)^(i-1)/factorial(i) * arg^i;
  end
  #println("Correction: ", 0.5ω₀a*sqrt(-lambert));
  return r + 0.5ω₀a*sqrt(-lambert);
end

"""
    merge_radial_gaussian_harmonic_freq(m, a, Ua, wa, b, Ub, wb)

Get the equivalent harmonic frequency of the trap in the radial direction given
the locations of the merging Gaussian potentials.
"""
function merge_radial_gaussian_harmonic_freq(m, a, Ua, wa, b, Ub, wb)
  # Imaginary values for repulsive potential, real for attractive.
  ω = 2.0*sqrt(complex(1/m*(Ub/wb^2*exp(-2(a-b)^2/wb^2)*(4(a-b)^2/wb^2 - 1) - Ua/wa^2)));
  return abs(ω);
end

function desired_trap_frequency2(γ, t, tfinal, ω0)
  s = t/tfinal;
  #println("s = ", s);
  ρ = 1 + 10*(γ-1)*s^3 - 15*(γ-1)*s^4 + 6*(γ-1)*s^5;
  #println("ρ = ", ρ);
  ρdd = (60*(γ-1)*s - 180*(γ-1)*s^2 + 120*(γ-1)*s^3)/Unitful.uconvert(unit(ω0)^-1, tfinal)^2;
  #println("ρdd = ", ρdd);
  return (ω0^2/ρ^4 - ρdd/ρ);
end

function tweezer_power_from_potential(U, w, α)
  return ((Unitful.c0 * w^2 * -U)/(4*ustrip(α)*Unitful.uconvert(Unitful.u"m", 1Unitful.u"a0_au")^3));
end

function Ua_from_ω2(ω2, m, Ub, wa, wb, a, b)
  return (wa^2*(Ub/wb^2 * exp(-2*(a-b)^2/wb^2)*((4*(a-b)^2)/wb^2 - 1) - m*ω2/4));
end

function Ub_from_ω2(ω2, m, Ua, wa, wb, a, b)
  return ((m*ω2/4 + Ua/wa^2) * wb^2/(exp(-2*(a-b)^2/wb^2)*((4*(a-b)^2)/wb^2 - 1)));
end
