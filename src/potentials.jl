#!/usr/bin/julia
#
# Definitions of useful potential functions for use in simulations.
#
using UnitfulAtomic;
export gs_polarisation, radial_gaussian, radial_gaussian_harmonic_freq,
       tweezer_potential_depth, simple_harmonic, translate_trajectory, merge_radial_gaussian_harmonic_freq;

"""
    gs_polarisation(atom::String, λ::Number)

Find the frequency dependent ground state polarisability for Rubidium and
Caesium at the given wavelength.
"""
function gs_polarisation(atom::String, λ::Number)
  # Apply the relevant data.
  # Data from M. S. Safronova et al., Phys. Rev. A 73, 022505 (2006).
  # https://doi-org.ezphost.dur.ac.uk/10.1103/PhysRevA.73.022505
  if atom == "Cs" || atom == "cs"
    dip12 = 4.4890;
    dip32 = 6.3238;
    δE12 = 0.050932;
    δE32 = 0.053456;
    A = 17.35;
  elseif atom == "Rb" || atom == "rb"
    dip12 = 4.231;
    dip32 = 5.977;
    δE12 = 0.057314;
    δE32 = 0.058396;
    A = 10.54;
  else throw(ArgumentError("only data for Rb and Cs has been implemented")); end

  # Calculate frequency in atomic units.
  ω = ustrip(auconvert(2π*Unitful.c0/λ));

  # Return the ground state dynamic polarisability.
  α = 1/3 * ((δE12 * dip12^2)/(δE12^2 - ω^2)
             + (δE32 * dip32^2)/(δE32^2 - ω^2))
      + A;

  # Apply the atomic units.
  return α * unit(1Unitful.u"a0_au^3");
end

"""
    radial_gaussian(ω₀::Number, U₀::Number, r::AbstractVector{T}) where T<:Number

Returns the numerical values for the radial slice of a Gaussian function with
the parameters given defined over the values contained in `r`.
"""
function radial_gaussian(ω₀::Number, U₀::Number, r::AbstractVector{T}) where T<:Number
  return U₀ * (1 .- exp.(-2r.^2 / ω₀^2));
end

"""
    radial_gaussian_harmonic_freq(ω₀::Number, U₀::Number, m::Number)

Calculate the radial harmonic frequency for the Gaussian potential with the
given parameters
"""
function radial_gaussian_harmonic_freq(ω₀::Number, U₀::Number, m::Number)
  (4U₀/(m * ω₀^2))^(1/2)
end

"""
    tweezer_potential_depth(P::Number, α::Number, ω₀::Number)

Calculate the trap depth, U₀, for an optical tweezer generated by a Gaussian
laser beam with power `P`, frequency-dependent atomic ground state
polarisability of `α` (in a₀³) and beam waist `ω₀`.

Uses the SI unit conversion of `α(C m²/V) = 4π ϵ₀ a₀³ α(a₀³)` with the potential
depth given by `U₀ = (P α)/(π c ϵ₀ ω₀²)`.
"""
function tweezer_potential_depth(P::Number, α::Number, ω₀::Number)
  return (4*ustrip(α)*Unitful.uconvert(Unitful.u"m", 1Unitful.u"a0_au")^3*P)/
         (Unitful.c0 * ω₀^2);
end

"""
    simple_harmonic(m::Number, ω::Number, x::AbstractVector{T}) where T<:Number

Returns the numerical values for the simple harmonic function with the
parameters given defined over the values contained in `x`.
"""
function simple_harmonic(m::Number, ω::Number, x::AbstractVector{T}) where T<:Number
  return 0.5 * m * ω^2 * x.^2;
end

"""
    translate_trajectory(r, b, Ua, ω₀a, Ub, ω₀b)

Translate between the intended trajectory for the minimum of the radial
component of two merging Gaussian potentials and the location of the potential.
"""
function translate_trajectory(r, b, Ua, ω₀a, Ub, ω₀b)
  wa = ω₀a;
  wb = ω₀b;

  expo4b2r2 = exp(4*(b^2 + r^2)/wb^2);
  expo2b2r2 = exp(2*(b^2 + r^2)/wb^2);

  longsqrt = sqrt(3)*sqrt(complex(wa^6*(-2*Ua^2*wb^4*expo4b2r2 + 27*Ub^2*wa^2*(b^2 - 2*b*r + r^2)*exp(8*b*r/wb^2))/ (expo4b2r2*Ua^2*wb^4)));

  postsqrt = -9*Ub*wa^4*(b - r)*exp(-2*(b^2 - 2*b*r + r^2)/wb^2)/(Ua*wb^2);

  # We want the first imaginary root of the general solution case.
  a = 3^(2/3)*(2^(2/3)*wa^2/3 + 3^(1/3)*(1 + sqrt(3)*im)* (12*r + 6^(1/3)*(1 + sqrt(3)*im)*(longsqrt + postsqrt)^(1/3))*(longsqrt + postsqrt)^(1/3)/36)/
            (((Ua*longsqrt*wb^2*expo2b2r2 + 9*Ub*wa^4*(-b + r)*exp(4*b*r/wb^2))/(expo2b2r2*Ua*wb^2))^(1/3)*(1 + sqrt(3)*im));

  # This is the full (unsimplified) expression.
  #a = 3^(2/3)*(2^(2/3)*wa^2/3 + 3^(1/3)*(1 + sqrt(3)*im)*(12*r + 6^(1/3)*(1 + sqrt(3)*im)*(-54*r^3 + 9*r*wa^2 + 9*r*(6*r^2 - wa^2) + sqrt(3)*sqrt(complex((-2*Ua^2*wa^6*wb^4*exp(4*b^2/wb^2 + 4*r^2/wb^2) + 27*(-2*Ua*r^3*wb^2*exp(2*b^2/wb^2 + 2*r^2/wb^2) + Ua*r*wa^2*wb^2*exp(2*b^2/wb^2 + 2*r^2/wb^2) + Ua*r*wb^2*(2*r^2 - wa^2)*exp(2*b^2/wb^2 + 2*r^2/wb^2) - Ub*b*wa^4*exp(4*b*r/wb^2) + Ub*r*wa^4*exp(4*b*r/wb^2))^2)*exp(-4*b^2/wb^2 - 4*r^2/wb^2)/(Ua^2*wb^4))) - 9*Ub*b*wa^4*exp(-2*b^2/wb^2 + 4*b*r/wb^2 - 2*r^2/wb^2)/(Ua*wb^2) + 9*Ub*r*wa^4*exp(-2*b^2/wb^2 + 4*b*r/wb^2 - 2*r^2/wb^2)/(Ua*wb^2))^(1/3))*(-54*r^3 + 9*r*wa^2 + 9*r*(6*r^2 - wa^2) + sqrt(3)*sqrt(complex((-2*Ua^2*wa^6*wb^4*exp(4*b^2/wb^2 + 4*r^2/wb^2) + 27*(-2*Ua*r^3*wb^2*exp(2*b^2/wb^2 + 2*r^2/wb^2) + Ua*r*wa^2*wb^2*exp(2*b^2/wb^2 + 2*r^2/wb^2) + Ua*r*wb^2*(2*r^2 - wa^2)*exp(2*b^2/wb^2 + 2*r^2/wb^2) - Ub*b*wa^4*exp(4*b*r/wb^2) + Ub*r*wa^4*exp(4*b*r/wb^2))^2)*exp(-4*b^2/wb^2 - 4*r^2/wb^2)/(Ua^2*wb^4))) - 9*Ub*b*wa^4*exp(-2*b^2/wb^2 + 4*b*r/wb^2 - 2*r^2/wb^2)/(Ua*wb^2) + 9*Ub*r*wa^4*exp(-2*b^2/wb^2 + 4*b*r/wb^2 - 2*r^2/wb^2)/(Ua*wb^2))^(1/3)/36)/(((-18*Ua*r^3*wb^2*exp(2*b^2/wb^2 + 2*r^2/wb^2) + 9*Ua*r*wa^2*wb^2*exp(2*b^2/wb^2 + 2*r^2/wb^2) + Ua*wb^2*(-36*r^3 + 9*r*(6*r^2 - wa^2) + sqrt(3)*sqrt(complex((-2*Ua^2*wa^6*wb^4*exp(4*b^2/wb^2 + 4*r^2/wb^2) + 27*(-2*Ua*r^3*wb^2*exp(2*b^2/wb^2 + 2*r^2/wb^2) + Ua*r*wa^2*wb^2*exp(2*b^2/wb^2 + 2*r^2/wb^2) + Ua*r*wb^2*(2*r^2 - wa^2)*exp(2*b^2/wb^2 + 2*r^2/wb^2) - Ub*b*wa^4*exp(4*b*r/wb^2) + Ub*r*wa^4*exp(4*b*r/wb^2))^2)*exp(-4*b^2/wb^2 - 4*r^2/wb^2)/(Ua^2*wb^4))))*exp(2*b^2/wb^2 + 2*r^2/wb^2) - 9*Ub*b*wa^4*exp(4*b*r/wb^2) + 9*Ub*r*wa^4*exp(4*b*r/wb^2))*exp(-2*b^2/wb^2 - 2*r^2/wb^2)/(Ua*wb^2))^(1/3)*(1 + sqrt(3)*im)); 
  a = Unitful.uconvert(unit(r), a)
  #println(a);
  # Has a small imaginary component which we'll ignore.
  return real(a);
end

# Similar to the above using the Lambert W function instead of a cubic expansion
# of the exponential.
function translate_trajectory_lambert(r, b, Ua, ω₀a, Ub, ω₀b)
  c = Ub/ω₀b^2 * (r-b) * exp(-2(r-b)^2/ω₀b^2);
  #arg = -2c^2 * ω₀a^2/Ua^2;
  arg = -(2c * ω₀a/Ua)^2;
  #println("Argument: ", arg);
  #argunit = unit(arg);
  #arg = ustrip(arg);
  if (abs(arg) > 1.0/exp(1))
    println("WARNING: outside of radius of convergence of series expansion!");
    println("Argument was ", arg);
  end
  #lambert = arg - arg^2 + 3/2*arg^3 - 8/3*arg^4 + 125/24*arg^5;
  #println(arg);
  #=
  lambert = 0.0;
  for i ∈ 1:5
    lambert += (-i)^(i-1)/factorial(i) * arg^i;
  end
  =#
  lamberthalf = 0.0;
  for i ∈ 0:6
    lamberthalf = 0.5*(i + 0.5)^(i -1)/factorial(i) * (-arg)^i;
  end
  lamberthalf *= sqrt(-arg);
  #L1 = log(-arg);
  #L2 = log(-L1);
  #lambert = L1 - L2;
  #for i ∈ 0:5, j ∈ 1:6
  #  lambert += (-1)^i * A * L1^(-i-j) * L2^j / factorial(j);
  #end
  #
  #lambert = L1-L2 + L2/L1 + L2*(-2+L2)/(2L1^2) + L2*(6-9L2+2L2^2)/(6L1^3) + L2*(-12+36L2-22L2^2+3L2^3)/(12L1^4);
  #lambert = lambertw(arg); # From LambertW package.
  #lambert *= argunit;
  #return r + ω₀a * sqrt(-0.5lambert);
  return r + 0.5ω₀a*lamberthalf;
  #return r + 0.5ω₀a*sqrt(-lambert);
end

"""
    merge_radial_gaussian_harmonic_freq(m, a, Ua, wa, b, Ub, wb)

Get the equivalent harmonic frequency of the trap in the radial direction given
the locations of the merging Gaussian potentials.
"""
function merge_radial_gaussian_harmonic_freq(m, a, Ua, wa, b, Ub, wb)

  #ω1 = 2.0*sqrt(complex((Ua*a/wa^2 + Ub/wb^2*exp(-2(a-b)^2/wb^2)*(b+4(a-b)^3/wb^2))/m));

  #ω1 = 2.0*sqrt(complex(-(Ua*wb^6*exp(2.0*(a^2 + b^2)/wb^2) - 16.0*Ub*a^4*wa^2*exp(4.0*a*b/wb^2) + 48.0*Ub*a^3*b*wa^2*exp(4.0*a*b/wb^2) - 48.0*Ub*a^2*b^2*wa^2*exp(4.0*a*b/wb^2) + 8.0*Ub*a^2*wa^2*wb^2*exp(4.0*a*b/wb^2) + 16.0*Ub*a*b^3*wa^2*exp(4.0*a*b/wb^2) - 4.0*Ub*a*b*wa^2*wb^2*exp(4.0*a*b/wb^2) - 4.0*Ub*b^2*wa^2*wb^2*exp(4.0*a*b/wb^2) + Ub*wa^2*wb^4*exp(4.0*a*b/wb^2))*exp(-2.0*(a^2 + b^2)/wb^2)/m))/(wa*wb^3);

  #expofac  = exp(2.0*(a^2 + b^2)/wb^2);
  #ω = 2.0*sqrt(complex(-(Ua*wb^4*expofac + Ub*wa^2*exp(4.0*a*b/wb^2)*(-4.0a^2 + 8.0*a*b -4.0*b^2 + wb^2))/(m*expofac)))/(wa*wb^2);

  #ω1 = 2.0*sqrt(complex(1/m*(Ua/wa^2 - Ub/wb^2*exp(-2*(a-b)^2/wb^2)*(1-4(a-b)^2/wb^2))));
  
  # Full un-simplified expression is:
  #ω = 2.0*sqrt(complex(-(Ua*wb^4*exp(2.0*(a^2 + b^2)/wb^2) - 4.0*Ub*a^2*wa^2*exp(4.0*a*b/wb^2) + 8.0*Ub*a*b*wa^2*exp(4.0*a*b/wb^2) - 4.0*Ub*b^2*wa^2*exp(4.0*a*b/wb^2) + Ub*wa^2*wb^2*exp(4.0*a*b/wb^2))*exp(-2.0*(a^2 + b^2)/wb^2)/m))/(wa*wb^2);
  #println('\n');
  #println("ω0 = ", ω);
  #println("ω1 = ", ω1);
  #println("ω2 = ", ω2);

  # Imaginary values for repulsive potential, real for attractive.
  ω = 2.0*sqrt(complex(1/m*(Ub/wb^2*exp(-2(a-b)^2/wb^2)*(4(a-b)^2/wb^2 - 1) - Ua/wa^2)));
  return abs(ω);
end

function desired_trap_frequency2(γ, t, tfinal, ω0)
  s = t/tfinal;
  #println("s = ", s);
  ρ = 1 + 10*(γ-1)*s^3 - 15*(γ-1)*s^4 + 6*(γ-1)*s^5;
  #println("ρ = ", ρ);
  ρdd = (60*(γ-1)*s - 180*(γ-1)*s^2 + 120*(γ-1)*s^3)/Unitful.uconvert(unit(ω0)^-1, tfinal)^2;
  #println("ρdd = ", ρdd);
  return (ω0^2/ρ^4 - ρdd/ρ);
  #=
  #println("ω = ", sqrt(complex(ω2)));
  #Ub = (m*ω2/4 + Ua/wa^2) * wb^2/(exp(-2*(a-b)^2/wb^2)*((4*(a-b)^2)/wb^2 - 1));
  Ua = wa^2*(Ub/wb^2 * exp(-2*(a-b)^2/wb^2)*((4*(a-b)^2)/wb^2 - 1) - m*ω2/4);
  P = (Unitful.c0 * wa^2 * -Ua)/(4*ustrip(αa)*Unitful.uconvert(Unitful.u"m", 1Unitful.u"a0_au")^3);
  return (sqrt(complex(ω2)), Ua, P);
  
  #return (Unitful.c0 * wb^2 * Ub)/(4*ustrip(αb)*Unitful.uconvert(Unitful.u"m", 1Unitful.u"a0_au")^3);
  =#
end

function tweezer_power_from_potential(U, w, α)
  return ((Unitful.c0 * w^2 * -U)/(4*ustrip(α)*Unitful.uconvert(Unitful.u"m", 1Unitful.u"a0_au")^3));
end

function Ua_from_ω2(ω2, m, Ub, wa, wb, a, b)
  return (wa^2*(Ub/wb^2 * exp(-2*(a-b)^2/wb^2)*((4*(a-b)^2)/wb^2 - 1) - m*ω2/4));
end

function Ub_from_ω2(ω2, m, Ua, wa, wb, a, b)
  return ((m*ω2/4 + Ua/wa^2) * wb^2/(exp(-2*(a-b)^2/wb^2)*((4*(a-b)^2)/wb^2 - 1)));
end
